/**
 * Challenge Scaffolding Utilities
 * 
 * Handles creating the directory structure and writing files for challenges.
 */

import fs from 'fs/promises';
import path from 'path';
import type { ChallengeGenerationResponse } from './ai-service.js';

export interface ScaffoldOptions {
  language: string;
  challengeNumber: number;
  challengeData: ChallengeGenerationResponse;
  basePath: string;
}

// Template files to copy for each language
const TEMPLATE_FILES: Record<string, string[]> = {
  typescript: [
    'package.json',
    'tsconfig.json',
    'vitest.config.ts',
    'eslint.config.js',
    '.prettierrc',
    '.gitignore',
  ],
  php: [
    'composer.json',
    'phpstan.neon',
    'phpunit.xml',
    '.php-cs-fixer.php',
    '.gitignore',
  ],
};

// Files that should NOT be generated by AI when template exists - these come from templates
const CONFIG_FILES = new Set([
  // TypeScript
  'package.json',
  'tsconfig.json',
  'vitest.config.ts',
  'eslint.config.js',
  '.prettierrc',
  'package-lock.json',
  'pnpm-lock.yaml',
  'yarn.lock',
  // PHP
  'composer.json',
  'composer.lock',
  'phpstan.neon',
  'phpunit.xml',
  '.php-cs-fixer.php',
  // Common
  '.gitignore',
]);

/**
 * Check if template exists for a language
 */
async function hasTemplate(language: string, basePath: string): Promise<boolean> {
  const templatePath = path.join(basePath, 'templates', language);
  try {
    await fs.access(templatePath);
    return true;
  } catch {
    return false;
  }
}

/**
 * Copy template files from templates/<language>/ to the challenge directory
 */
async function copyTemplateFiles(
  language: string,
  challengePath: string,
  basePath: string
): Promise<boolean> {
  const templatePath = path.join(basePath, 'templates', language);
  
  if (!(await hasTemplate(language, basePath))) {
    console.log(`  ‚ÑπÔ∏è  No template found for '${language}' - AI will generate all files`);
    return false;
  }

  const filesToCopy = TEMPLATE_FILES[language] ?? [];
  let copiedCount = 0;
  
  for (const file of filesToCopy) {
    const sourcePath = path.join(templatePath, file);
    const destPath = path.join(challengePath, file);
    
    try {
      await fs.copyFile(sourcePath, destPath);
      copiedCount++;
    } catch (error) {
      // File might not exist in template, that's ok
      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
        throw error;
      }
    }
  }
  
  if (copiedCount > 0) {
    console.log(`  ‚úì Copied ${copiedCount} template files`);
  }
  return true;
}

/**
 * Filter out config files from AI-generated file list (only when template exists)
 */
function filterConfigFiles(files: Array<{path: string, content: string}>, templateExists: boolean): Array<{path: string, content: string}> {
  if (!templateExists) {
    // No template - allow AI to generate everything including config files
    return files;
  }
  
  // Template exists - filter out config files that come from template
  return files.filter(file => {
    const basename = path.basename(file.path);
    if (CONFIG_FILES.has(basename)) {
      return false;
    }
    return true;
  });
}

/**
 * Normalize test file path - ensure it's directly in tests/, not nested
 */
function normalizeTestPath(filePath: string): string {
  // Remove any leading 'tests/' or 'test/' from the path to avoid double-nesting
  let normalized = filePath;
  if (normalized.startsWith('tests/')) {
    normalized = normalized.slice(6);
  } else if (normalized.startsWith('test/')) {
    normalized = normalized.slice(5);
  }
  return normalized;
}

/**
 * Clean the slug to remove any numeric prefix that might duplicate the challenge number.
 * Handles cases where AI returns slugs like "005-nested-form-validator".
 */
function cleanSlug(slug: string, challengeNumber: number): string {
  const numStr = String(challengeNumber).padStart(3, '0');
  // Remove leading pattern like "005-" or "005_" from slug
  const cleaned = slug.replace(new RegExp(`^${numStr}[-_]`), '');
  return cleaned || slug; // If cleaning removed everything, return original
}

export async function scaffoldChallenge(options: ScaffoldOptions): Promise<string> {
  const { language, challengeNumber, challengeData, basePath } = options;
  
  // Clean the slug to prevent duplicate numbering (e.g., "005-005-nested-form-validator")
  const cleanChallengeSlug = cleanSlug(challengeData.slug, challengeNumber);
  
  // Create challenge directory name
  const challengeDirName = `${String(challengeNumber).padStart(3, '0')}-${cleanChallengeSlug}`;
  const challengePath = path.join(basePath, 'challenges', language, challengeDirName);
  
  console.log(`\nüìÅ Creating challenge at: ${challengePath}`);
  
  // Ensure parent directories exist
  await fs.mkdir(challengePath, { recursive: true });
  
  // Check if template exists and copy template files FIRST
  console.log('\nüìã Setting up template...');
  const templateExists = await copyTemplateFiles(language, challengePath, basePath);
  
  // Create subdirectories
  const solutionPath = path.join(challengePath, 'solution', 'src');
  const testsPath = path.join(challengePath, 'tests');
  const srcPath = path.join(challengePath, 'src');
  
  await fs.mkdir(solutionPath, { recursive: true });
  await fs.mkdir(testsPath, { recursive: true });
  await fs.mkdir(srcPath, { recursive: true });
  
  // Write README.md
  await fs.writeFile(
    path.join(challengePath, 'README.md'),
    challengeData.readme,
    'utf-8'
  );
  console.log('  ‚úì Created README.md');
  
  // Filter config files only if template exists
  const filteredStarterFiles = filterConfigFiles(challengeData.starterFiles, templateExists);
  const filteredSolutionFiles = filterConfigFiles(challengeData.solutionFiles, templateExists);
  const filteredTestFiles = filterConfigFiles(challengeData.testFiles, templateExists);
  
  // Write starter files directly to src/
  console.log('\nüìù Writing starter files to src/...');
  for (const file of filteredStarterFiles) {
    const filePath = path.join(srcPath, path.basename(file.path));
    await fs.writeFile(filePath, file.content, 'utf-8');
    console.log(`  ‚úì Created src/${path.basename(file.path)}`);
  }
  
  // Write solution files to solution/src/
  console.log('\nüìù Writing solution files...');
  for (const file of filteredSolutionFiles) {
    const filePath = path.join(challengePath, 'solution', file.path);
    await ensureDirectoryExists(filePath);
    await fs.writeFile(filePath, file.content, 'utf-8');
    console.log(`  ‚úì Created solution/${file.path}`);
  }
  
  // Write test files to tests/
  console.log('\nüß™ Writing test files...');
  for (const file of filteredTestFiles) {
    const normalizedPath = normalizeTestPath(file.path);
    const filePath = path.join(testsPath, normalizedPath);
    await ensureDirectoryExists(filePath);
    await fs.writeFile(filePath, file.content, 'utf-8');
    console.log(`  ‚úì Created tests/${normalizedPath}`);
  }
  
  console.log('\n‚úÖ Challenge scaffolded successfully!');
  console.log(`\nüìÇ Location: ${challengePath}`);
  
  if (templateExists) {
    console.log('\nNext steps:');
    console.log(`  1. cd ${challengePath}`);
    if (language === 'typescript') {
      console.log(`  2. npm install`);
      console.log(`  3. npm run test`);
    } else if (language === 'php') {
      console.log(`  2. composer install`);
      console.log(`  3. composer test`);
    }
  }
  
  return challengePath;
}

async function ensureDirectoryExists(filePath: string): Promise<void> {
  const dir = path.dirname(filePath);
  await fs.mkdir(dir, { recursive: true });
}

export async function getNextChallengeNumber(language: string, basePath: string): Promise<number> {
  const challengesDir = path.join(basePath, 'challenges', language);
  
  try {
    const entries = await fs.readdir(challengesDir);
    const challengeDirs = entries.filter(entry => /^\d{3}-/.test(entry));
    
    if (challengeDirs.length === 0) {
      return 1;
    }
    
    // Extract numbers and find the highest
    const numbers = challengeDirs.map(dir => {
      const match = dir.match(/^(\d{3})-/);
      return match ? parseInt(match[1], 10) : 0;
    });
    
    return Math.max(...numbers) + 1;
  } catch (error) {
    // Directory doesn't exist yet
    return 1;
  }
}
